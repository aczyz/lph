
==================== FINAL INTERFACE ====================
2018-05-10 09:49:55.358799916 UTC

interface lph-0.1.0.0-9ChSTD8BH50CCOnZTmPQ4C:Formulas 8022
  interface hash: 16286826222478c3ce1360ea119e4c6d
  ABI hash: 29828620833d925386bc7e66a6485a46
  export-list hash: 18cdaffd124661ac46eb1dd5b1e7aefc
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 26e0ff4b0ff758fc4ebf6a516aed248e
  sig of: Nothing
  used TH splices: False
  where
exports:
  Formulas.bP
  Formulas.bPBody
  Formulas.bPBodyP
  Formulas.bPHead
  Formulas.bPHead'
  Formulas.hClBody
  Formulas.hClBodyN
  Formulas.hClBodyP
  Formulas.hClHead
  Formulas.Atom{Formulas.A}
  Formulas.HClause
  Formulas.LogicP
module dependencies:
package dependencies: base-4.10.1.0* ghc-prim-0.5.1.1
                      integer-gmp-1.0.1.0
orphans: base-4.10.1.0:GHC.Float base-4.10.1.0:GHC.Base
family instance modules: base-4.10.1.0:Control.Applicative
                         base-4.10.1.0:Data.Either base-4.10.1.0:Data.Functor.Const
                         base-4.10.1.0:Data.Functor.Identity base-4.10.1.0:Data.Monoid
                         base-4.10.1.0:Data.Type.Equality base-4.10.1.0:GHC.Generics
                         base-4.10.1.0:GHC.IO.Exception base-4.10.1.0:GHC.TypeLits
                         base-4.10.1.0:GHC.TypeNats
import  -/  base-4.10.1.0:Data.List 4ab7fa2a1b87502b23af891a384f0506
import  -/  base-4.10.1.0:Data.OldList 555420b092ca8cf0a8f9666bc0e07dcf
import  -/  base-4.10.1.0:GHC.Base 782fd99b5e36f3698a26179a49afca64
import  -/  base-4.10.1.0:GHC.Show 0a8ce2b5e533d1c2cfb7954e6736be45
import  -/  base-4.10.1.0:Prelude 31945b7d0084063347fc52506d3a4020
import  -/  ghc-prim-0.5.1.1:GHC.Classes 93e2660065dce9329577e83d76d8f0d4
5e63cb212f133c594f84fba19ed012fa
  $fEqAtom :: GHC.Classes.Eq Formulas.Atom
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Formulas.Atom Formulas.$fEqAtom_$c== Formulas.$fEqAtom_$c/= -}
5e63cb212f133c594f84fba19ed012fa
  $fEqAtom_$c/= :: Formulas.Atom -> Formulas.Atom -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)),1*U(1*U(U))><S(S(S)),1*U(1*U(U))>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Formulas.Atom) (y :: Formulas.Atom) ->
                 case x of wild { Formulas.A a ->
                 case y of wild1 { Formulas.A b ->
                 case GHC.Classes.eqInt a b of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False } } }) -}
5e63cb212f133c594f84fba19ed012fa
  $fEqAtom_$c== :: Formulas.Atom -> Formulas.Atom -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)),1*U(1*U(U))><S(S(S)),1*U(1*U(U))>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Formulas.Atom) (ds1 :: Formulas.Atom) ->
                 case ds of wild { Formulas.A a ->
                 case ds1 of wild1 { Formulas.A b -> GHC.Classes.eqInt a b } }) -}
5e63cb212f133c594f84fba19ed012fa
  $fOrdAtom :: GHC.Classes.Ord Formulas.Atom
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Formulas.Atom
                  Formulas.$fEqAtom
                  Formulas.$fOrdAtom_$ccompare
                  Formulas.$fOrdAtom_$c<
                  Formulas.$fOrdAtom_$c<=
                  Formulas.$fOrdAtom_$c>
                  Formulas.$fOrdAtom_$c>=
                  Formulas.$fOrdAtom_$cmax
                  Formulas.$fOrdAtom_$cmin -}
5e63cb212f133c594f84fba19ed012fa
  $fOrdAtom_$c< :: Formulas.Atom -> Formulas.Atom -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)),1*U(1*U(U))><S(S(S)),1*U(1*U(U))>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Formulas.Atom) (y :: Formulas.Atom) ->
                 case x of wild { Formulas.A a ->
                 case y of wild1 { Formulas.A b ->
                 case a of wild2 { GHC.Types.I# x# ->
                 case b of wild3 { GHC.Types.I# y# ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.<# x# y#) } } } }) -}
5e63cb212f133c594f84fba19ed012fa
  $fOrdAtom_$c<= :: Formulas.Atom -> Formulas.Atom -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)),1*U(1*U(U))><S(S(S)),1*U(1*U(U))>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Formulas.Atom) (y :: Formulas.Atom) ->
                 case x of wild { Formulas.A a ->
                 case y of wild1 { Formulas.A b ->
                 case a of wild2 { GHC.Types.I# x# ->
                 case b of wild3 { GHC.Types.I# y# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# x# y#) of wild4 {
                   GHC.Types.False
                   -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.==# x# y#)
                   GHC.Types.True -> GHC.Types.True } } } } }) -}
5e63cb212f133c594f84fba19ed012fa
  $fOrdAtom_$c> :: Formulas.Atom -> Formulas.Atom -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)),1*U(1*U(U))><S(S(S)),1*U(1*U(U))>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Formulas.Atom) (y :: Formulas.Atom) ->
                 case x of wild { Formulas.A a ->
                 case y of wild1 { Formulas.A b ->
                 case a of wild2 { GHC.Types.I# x# ->
                 case b of wild3 { GHC.Types.I# y# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# x# y#) of wild4 {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# x# y#) of wild5 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False }
                   GHC.Types.True -> GHC.Types.False } } } } }) -}
5e63cb212f133c594f84fba19ed012fa
  $fOrdAtom_$c>= :: Formulas.Atom -> Formulas.Atom -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)),1*U(1*U(U))><S(S(S)),1*U(1*U(U))>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Formulas.Atom) (y :: Formulas.Atom) ->
                 case x of wild { Formulas.A a ->
                 case y of wild1 { Formulas.A b ->
                 case a of wild2 { GHC.Types.I# x# ->
                 case b of wild3 { GHC.Types.I# y# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# x# y#) of wild4 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False } } } } }) -}
5e63cb212f133c594f84fba19ed012fa
  $fOrdAtom_$ccompare ::
    Formulas.Atom -> Formulas.Atom -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)),1*U(1*U(U))><S(S(S)),1*U(1*U(U))>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Formulas.Atom) (ds1 :: Formulas.Atom) ->
                 case ds of wild { Formulas.A a ->
                 case ds1 of wild1 { Formulas.A b ->
                 GHC.Classes.compareInt a b } }) -}
5e63cb212f133c594f84fba19ed012fa
  $fOrdAtom_$cmax :: Formulas.Atom -> Formulas.Atom -> Formulas.Atom
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)),1*U(U(U))><S(S(S)),1*U(U(U))>m,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Formulas.Atom) (y :: Formulas.Atom) ->
                 case x of wild { Formulas.A a ->
                 case y of wild1 { Formulas.A b ->
                 case a of wild2 { GHC.Types.I# x# ->
                 case b of wild3 { GHC.Types.I# y# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# x# y#) of wild4 {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# x# y#) of wild5 {
                        GHC.Types.False -> wild GHC.Types.True -> wild1 }
                   GHC.Types.True -> wild1 } } } } }) -}
5e63cb212f133c594f84fba19ed012fa
  $fOrdAtom_$cmin :: Formulas.Atom -> Formulas.Atom -> Formulas.Atom
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)),1*U(U(U))><S(S(S)),1*U(U(U))>m,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Formulas.Atom) (y :: Formulas.Atom) ->
                 case x of wild { Formulas.A a ->
                 case y of wild1 { Formulas.A b ->
                 case a of wild2 { GHC.Types.I# x# ->
                 case b of wild3 { GHC.Types.I# y# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# x# y#) of wild4 {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# x# y#) of wild5 {
                        GHC.Types.False -> wild1 GHC.Types.True -> wild }
                   GHC.Types.True -> wild } } } } }) -}
5e63cb212f133c594f84fba19ed012fa
  $fShowAtom :: GHC.Show.Show Formulas.Atom
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Formulas.Atom
                  Formulas.$fShowAtom_$cshowsPrec
                  Formulas.$fShowAtom_$cshow
                  Formulas.$fShowAtom_$cshowList -}
5e63cb212f133c594f84fba19ed012fa
  $fShowAtom1 :: Formulas.Atom -> GHC.Show.ShowS
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(1*U(U))><L,U>,
     Unfolding: (\ (w :: Formulas.Atom) (w1 :: GHC.Base.String) ->
                 case w of ww { Formulas.A ww1 ->
                 Formulas.$w$cshowsPrec 0# ww1 w1 }) -}
40eb89e811891760e1624d17743b3891
  $fShowAtom2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("A "#) -}
5e63cb212f133c594f84fba19ed012fa
  $fShowAtom_$cshow :: Formulas.Atom -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(1*U(U))>,
     Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Formulas.Atom) ->
                 case w of ww { Formulas.A ww1 -> Formulas.$w$cshow ww1 }) -}
5e63cb212f133c594f84fba19ed012fa
  $fShowAtom_$cshowList :: [Formulas.Atom] -> GHC.Show.ShowS
  {- Arity: 2, HasNoCafRefs,
     Unfolding: (GHC.Show.showList__
                   @ Formulas.Atom
                   Formulas.$fShowAtom1) -}
5e63cb212f133c594f84fba19ed012fa
  $fShowAtom_$cshowsPrec ::
    GHC.Types.Int -> Formulas.Atom -> GHC.Show.ShowS
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S),1*U(U)><S,1*U(1*U(U))><L,U>, Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Formulas.Atom)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Formulas.A ww3 ->
                 Formulas.$w$cshowsPrec ww1 ww3 w2 } }) -}
bd5b4e914c17fb59ca571a3184ad6c23
  $tc'A :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12126243412558115280##
                   16619915189712213621##
                   Formulas.$trModule
                   Formulas.$tc'A2
                   0#
                   Formulas.$tc'A1) -}
a81c7d926599488107f468cde10b1ccb
  $tc'A1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
7b2b38ae0e2b3dab5547935b0d564cef
  $tc'A2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Formulas.$tc'A3) -}
f5737d27c3e0f39c329aac601bdd7bd1
  $tc'A3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'A"#) -}
f537a0cca0482385bf800af57f23ee3b
  $tcAtom :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15859982947578071877##
                   17541791004257594969##
                   Formulas.$trModule
                   Formulas.$tcAtom1
                   0#
                   GHC.Types.krep$*) -}
70e41bb65618642ac5e0ae4f6c33e071
  $tcAtom1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Formulas.$tcAtom2) -}
f29a679e49ab06dfac5acaeb4d35ee67
  $tcAtom2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Atom"#) -}
f3f13688893b55989d4255066bac6386
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Formulas.$trModule3
                   Formulas.$trModule1) -}
2d0e142f5532042db96c32795de2908a
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Formulas.$trModule2) -}
4e966d7140546ed9fe483f908bed8c61
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Formulas"#) -}
41fc1a69d2566261316e081750ce0ba4
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Formulas.$trModule4) -}
91a8af734be9931ac3e60d305e58bcd2
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("lph-0.1.0.0-9ChSTD8BH50CCOnZTmPQ4C"#) -}
1ddf200d7ab7460e4edd722fb21871b4
  $w$cshow :: GHC.Types.Int -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <L,1*U(U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Types.Int) ->
                 GHC.CString.unpackAppendCString#
                   Formulas.$fShowAtom2
                   (case ww of ww2 { GHC.Types.I# ww3 ->
                    case GHC.Show.$wshowSignedInt
                           11#
                           ww3
                           (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                    GHC.Types.: @ GHC.Types.Char ww5 ww6 } })) -}
f5a1cbbac53a42ccc95eae38269eb012
  $w$cshowsPrec ::
    GHC.Prim.Int#
    -> GHC.Types.Int -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, HasNoCafRefs, Strictness: <S,U><L,1*U(U)><L,U>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (w :: GHC.Base.String) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False
                   -> GHC.CString.unpackAppendCString#
                        Formulas.$fShowAtom2
                        (case ww1 of ww2 { GHC.Types.I# ww3 ->
                         case GHC.Show.$wshowSignedInt 11# ww3 w of ww4 { (#,#) ww5 ww6 ->
                         GHC.Types.: @ GHC.Types.Char ww5 ww6 } })
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (GHC.CString.unpackAppendCString#
                           Formulas.$fShowAtom2
                           (case ww1 of ww2 { GHC.Types.I# ww3 ->
                            case GHC.Show.$wshowSignedInt
                                   11#
                                   ww3
                                   (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.$fShow(,)2
                                      w) of ww4 { (#,#) ww5 ww6 ->
                            GHC.Types.: @ GHC.Types.Char ww5 ww6 } })) }) -}
5e63cb212f133c594f84fba19ed012fa
  data Atom = A GHC.Types.Int
0b2a8e4566400f449d194587bf23a956
  type HClause = (Formulas.Atom, [Formulas.Atom], [Formulas.Atom])
677480e6f3d861e38d8ed3d2537b7d36
  type LogicP = [Formulas.HClause]
88ea949769107c8f2be51f50ca3e3425
  bP :: Formulas.LogicP -> [Formulas.Atom]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [Formulas.HClause]) ->
                 case ds of wild {
                   [] -> GHC.Types.[] @ Formulas.Atom
                   : ipv ipv1
                   -> Data.OldList.nubBy
                        @ Formulas.Atom
                        Formulas.$fEqAtom_$c==
                        (GHC.Base.++
                           @ Formulas.Atom
                           (Formulas.bPHead wild)
                           (Formulas.bPBody wild)) }) -}
ac4f3d230a8f395522a17d3379c04a78
  bPBody :: Formulas.LogicP -> [Formulas.Atom]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
3324ac12b209b61a7759b3ac32440392
  bPBodyP :: Formulas.LogicP -> [Formulas.Atom]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
db2886ee4541d23fd699dcfe68b2a44a
  bPHead :: Formulas.LogicP -> [Formulas.Atom]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
bf20ae683c56dc53367bb7e07780bede
  bPHead' :: Formulas.LogicP -> [Formulas.Atom]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
42175d242c9bfc43cef80fa8a2ede676
  hClBody :: Formulas.HClause -> [Formulas.Atom]
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(A,1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (Formulas.Atom, [Formulas.Atom], [Formulas.Atom])) ->
                 case ds of wild { (,,) ds1 ds2 ds3 ->
                 case ds2 of wild1 {
                   [] -> ds3
                   : ipv ipv1
                   -> GHC.Base.augment
                        @ Formulas.Atom
                        (\ @ b (c :: Formulas.Atom -> b -> b)[OneShot] (n :: b)[OneShot] ->
                         GHC.Base.foldr @ Formulas.Atom @ b c n wild1)
                        ds3 } }) -}
8e606056e37697b8aaa97577355df513
  hClBodyN :: Formulas.HClause -> [Formulas.Atom]
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLS),1*U(A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (Formulas.Atom, [Formulas.Atom], [Formulas.Atom])) ->
                 case ds of wild { (,,) ds1 ds2 ds3 -> ds3 }) -}
a19a022d4748f44604db81ae2ec901fc
  hClBodyP :: Formulas.HClause -> [Formulas.Atom]
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (Formulas.Atom, [Formulas.Atom], [Formulas.Atom])) ->
                 case ds of wild { (,,) ds1 ds2 ds3 -> ds2 }) -}
78d0c0794c4a586076e791218a1f42ed
  hClHead :: Formulas.HClause -> [Formulas.Atom]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,A,A)>m2,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (Formulas.Atom, [Formulas.Atom], [Formulas.Atom])) ->
                 case ds of wild { (,,) x ds1 ds2 ->
                 GHC.Types.: @ Formulas.Atom x (GHC.Types.[] @ Formulas.Atom) }) -}
instance [safe] GHC.Classes.Eq [Formulas.Atom] = Formulas.$fEqAtom
instance [safe] GHC.Classes.Ord [Formulas.Atom]
  = Formulas.$fOrdAtom
instance [safe] GHC.Show.Show [Formulas.Atom] = Formulas.$fShowAtom
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

